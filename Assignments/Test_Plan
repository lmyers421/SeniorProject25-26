# Test Plan and Results

## Overall Test Plan

## Test Case Descriptions

LD1.1 **League Data API Test 1**  
LD1.2 This test will ensure that the backend can successfully retrieve game or match data for a supported league using an external API.  
LD1.3 For this test, the backend will issue a request to the league data endpoint using a valid league identifier and date range. The returned data will be verified to ensure it matches the requested league and timeframe.  
LD1.4 Inputs: League identifier (e.g., NBA, NFL, NHL, LoL, Overwatch), Start date, End date  
LD1.5 Outputs: Game or match data for the specified league is returned, No API or server errors occur  
LD1.6 Normal  
LD1.7 Blackbox  
LD1.8 Functional  
LD1.9 Integration  
LD1.10 Results: Game or match data was successfully retrieved for the selected league and date range.  

LD2.1 **League Data API Test 2**  
LD2.2 This test will verify proper handling of invalid or unsupported league identifiers.  
LD2.3 For this test, a request will be sent to the backend using a league identifier that is not supported by the system.  
LD2.4 Inputs: Unsupported league identifier  
LD2.5 Outputs: An error message or empty response is returned, Appropriate HTTP status code is provided  
LD2.6 Abnormal  
LD2.7 Blackbox  
LD2.8 Functional  
LD2.9 Integration  
LD2.10 Results: The backend correctly rejected the unsupported league request.  

LD3.1 **League Data API Test 3**  
LD3.2 This test will verify that the backend correctly handles invalid date ranges for any supported league.  
LD3.3 For this test, a request will be sent with an end date that occurs before the start date.  
LD3.4 Inputs: Valid league identifier, Start date after end date  
LD3.5 Outputs: Error response or validation message returned  
LD3.6 Abnormal  
LD3.7 Blackbox  
LD3.8 Functional  
LD3.9 Integration  
LD3.10 Results: The backend correctly handled the invalid date range.  

LD4.1 **League Data API Test 4**    
LD4.2 This test will ensure consistent response structure across different leagues.  
LD4.3 For this test, requests will be made to multiple supported league endpoints and the response format will be compared to ensure consistency.  
LD4.4 Inputs: Multiple valid league identifiers, Valid date ranges   
LD4.5 Outputs: Responses follow a consistent schema regardless of league  
LD4.6 Normal  
LD4.7 Whitebox  
LD4.8 Functional  
LD4.9 Integration  
LD4.10 Results: All league responses followed the standardized backend data format.  

PS1.1 **Prediction Submission Test 1**    
PS1.2 This test will ensure that users can submit predictions for games or matches across any supported league.  
PS1.3 For this test, a logged-in user will submit a prediction for an upcoming match. The system should store the prediction correctly in the database.  
PS1.4 Inputs: Logged-in user, Valid match identifier, User prediction  
PS1.5 Outputs: Prediction saved to the database, Confirmation returned to user  
PS1.6 Normal  
PS1.7 Blackbox  
PS1.8 Functional  
PS1.9 Integration  
PS1.10 Results: Prediction was successfully stored and associated with the correct user and match.  

AB1.1 **Adding/Creating Bracket Test**
AB1.2 Purpose: Adding/creating a bracket is a key component of our app, so we want to ensure that doing so is correct all of the time.
AB1.3 Description: The user will go to the brackets page, and add a bracket, then ensure that the user can add other users/friends to the bracket, make picks, and everything works as expected within the app and the backend.
AB1.4 Inputs: add a bracket, make picks
AB1.5 Expected outputs/results: bracket gets added to user’s account, backend, etc.  User is able to make picks and they will save to their profile.
AB1.6 Normal 
AB1.7 Blackbox 
AB1.8 Functional 
AB 1.9 Unit

SF1.1 **Settings Functionality Test**
SF1.2 Purpose: To ensure that all options in the settings menu can be enabled/changed and they work as intended.
SF1.3 For each option in the settings menu, the user will change it and then test the application, with special notes for the specific setting that has been changed to ensure that it does what it is supposed to do.
SF1.4 Inputs: The only inputs are the settings on the settings page.
SF1.5 Expected outputs/results: The app should continue to function normally despite the settings changed, with differences depending on the setting that is changed.
SF1.6 Normal 
SF1.7 Whitebox
SF1.8 Functional 
SF1.9 Integration

NM1.1 **Navigation/Menu Testing**
NM1.2 Purpose: user can freely navigate the app using all the menu features
NM1.3 Description; user will ensure that all menu/navigation features work from any place on the app, so they don’t have to go through sub-menus or multiple screens to get where they want to go.
NM1.4 Inputs used for test: Purely mouse controls, clicking on pop-out menu and navigating to each page by clicking.
NM1.5 Expected outputs/results: User will be able to get to any page from any other page with only a few clicks, and no sub-menus
NM1.6 Normal 
NM1.7 Blackbox 
NM1.8 Functional 
NM1.9 Integration 
